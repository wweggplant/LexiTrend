# Story 3.3: 将成功的 API 结果缓存在本地 IndexedDB

## Status: Review

## Story

- As a 用户
- I want 插件能将**成功获取的 API 结果缓存在本地 (IndexedDB)**
- so that 当我再次查询同一个词时，可以瞬间得到结果，从而节省时间和避免重复的 API 消费

## Acceptance Criteria (ACs)

1.  [x] 在 `ApiService` 成功从 Gemini API 获取到洞察结果后，会调用 `CacheService.set()` 方法。
2.  [x] `CacheService` 会将关键词和对应的洞察结果作为一个键值对存入 IndexedDB。
3.  [x] 在 `ApiService` 准备发起新的 API 调用之前，会先调用 `CacheService.get()` 方法检查是否存在有效的缓存。
4.  [x] 如果缓存命中（`CacheService.get()` 返回了数据），则直接返回缓存数据，不再进行真实的 API 调用。
5.  [x] 从缓存返回的数据，其响应速度应明显快于真实 API 调用（目标 < 100ms）。
6.  [x] 缓存的键（key）应具有确定性，能唯一标识一次查询（例如，基于关键词和语言）。

## Tasks / Subtasks

- [x] **Task 1: 在 ApiService 中集成缓存写入逻辑**
  - [x] 修改 `ApiService.analyzeKeyword()` 方法。
  - [x] 在从 Gemini API 成功获取到 `response` 对象后，但在 `return` 之前，增加一步操作：
  - [x] 调用 `await cacheService.set(cacheKey, response)`，将结果存入缓存。
  - [x] `cacheKey` 应根据关键词和语言生成，例如 `const cacheKey = \`insight:${language}:${keyword}\`;`。

- [x] **Task 2: 在 ApiService 中集成缓存读取逻辑**
  - [x] 在 `ApiService.analyzeKeyword()` 方法的入口处，即发起真实 API 调用之前，增加一步操作：
  - [x] 生成与写入时规则相同的 `cacheKey`。
  - [x] 调用 `const cachedData = await cacheService.get(cacheKey)`。
  - [x] 如果 `cachedData` 不为 `null`，则直接 `return cachedData`，中断后续的真实 API 调用流程。

- [x] **Task 3: 验证缓存效果**
  - [x] 编写一个集成测试或手动测试场景。
  - [x] 第一次查询某个关键词，观察网络请求和响应时间。
  - [x] 第二次查询同一个关键词，确认没有新的网络请求发出，并且响应时间显著缩短。
  - [x] 通过浏览器的开发者工具，检查 IndexedDB 中是否已成功存入数据。 